
/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GeneratePropsH.js
 */
#pragma once

#include <react/renderer/components/view/ViewProps.h>
#include <react/renderer/core/PropsParserContext.h>
#include <react/renderer/core/propsConversions.h>
#include <vector>

namespace facebook::react {

struct RNCNaverMapCircleCoordStruct {
  double latitude;
  double longitude;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapCircleCoordStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapCircleCoordStruct &value) {
  return "[Object RNCNaverMapCircleCoordStruct]";
}
class RNCNaverMapCircleProps final : public ViewProps {
 public:
  RNCNaverMapCircleProps() = default;
  RNCNaverMapCircleProps(const PropsParserContext& context, const RNCNaverMapCircleProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  RNCNaverMapCircleCoordStruct coord{};
  double radius{0.0};
  int color{0};
  int outlineColor{0};
  double outlineWidth{0.0};
};

struct RNCNaverMapMarkerCoordStruct {
  double latitude;
  double longitude;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerCoordStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapMarkerCoordStruct &value) {
  return "[Object RNCNaverMapMarkerCoordStruct]";
}

struct RNCNaverMapMarkerAnchorStruct {
  double x;
  double y;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerAnchorStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_x = map.find("x");
  if (tmp_x != map.end()) {
    fromRawValue(context, tmp_x->second, result.x);
  }
  auto tmp_y = map.find("y");
  if (tmp_y != map.end()) {
    fromRawValue(context, tmp_y->second, result.y);
  }
}

static inline std::string toString(const RNCNaverMapMarkerAnchorStruct &value) {
  return "[Object RNCNaverMapMarkerAnchorStruct]";
}

struct RNCNaverMapMarkerImageStruct {
  std::string symbol;
  std::string rnAssetUri;
  std::string httpUri;
  std::string assetName;
  std::string reuseIdentifier;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerImageStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_symbol = map.find("symbol");
  if (tmp_symbol != map.end()) {
    fromRawValue(context, tmp_symbol->second, result.symbol);
  }
  auto tmp_rnAssetUri = map.find("rnAssetUri");
  if (tmp_rnAssetUri != map.end()) {
    fromRawValue(context, tmp_rnAssetUri->second, result.rnAssetUri);
  }
  auto tmp_httpUri = map.find("httpUri");
  if (tmp_httpUri != map.end()) {
    fromRawValue(context, tmp_httpUri->second, result.httpUri);
  }
  auto tmp_assetName = map.find("assetName");
  if (tmp_assetName != map.end()) {
    fromRawValue(context, tmp_assetName->second, result.assetName);
  }
  auto tmp_reuseIdentifier = map.find("reuseIdentifier");
  if (tmp_reuseIdentifier != map.end()) {
    fromRawValue(context, tmp_reuseIdentifier->second, result.reuseIdentifier);
  }
}

static inline std::string toString(const RNCNaverMapMarkerImageStruct &value) {
  return "[Object RNCNaverMapMarkerImageStruct]";
}

struct RNCNaverMapMarkerCaptionStruct {
  std::string key;
  std::string text;
  double requestedWidth;
  int align;
  double offset;
  int color;
  int haloColor;
  double textSize;
  double minZoom;
  double maxZoom;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerCaptionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_key = map.find("key");
  if (tmp_key != map.end()) {
    fromRawValue(context, tmp_key->second, result.key);
  }
  auto tmp_text = map.find("text");
  if (tmp_text != map.end()) {
    fromRawValue(context, tmp_text->second, result.text);
  }
  auto tmp_requestedWidth = map.find("requestedWidth");
  if (tmp_requestedWidth != map.end()) {
    fromRawValue(context, tmp_requestedWidth->second, result.requestedWidth);
  }
  auto tmp_align = map.find("align");
  if (tmp_align != map.end()) {
    fromRawValue(context, tmp_align->second, result.align);
  }
  auto tmp_offset = map.find("offset");
  if (tmp_offset != map.end()) {
    fromRawValue(context, tmp_offset->second, result.offset);
  }
  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_haloColor = map.find("haloColor");
  if (tmp_haloColor != map.end()) {
    fromRawValue(context, tmp_haloColor->second, result.haloColor);
  }
  auto tmp_textSize = map.find("textSize");
  if (tmp_textSize != map.end()) {
    fromRawValue(context, tmp_textSize->second, result.textSize);
  }
  auto tmp_minZoom = map.find("minZoom");
  if (tmp_minZoom != map.end()) {
    fromRawValue(context, tmp_minZoom->second, result.minZoom);
  }
  auto tmp_maxZoom = map.find("maxZoom");
  if (tmp_maxZoom != map.end()) {
    fromRawValue(context, tmp_maxZoom->second, result.maxZoom);
  }
}

static inline std::string toString(const RNCNaverMapMarkerCaptionStruct &value) {
  return "[Object RNCNaverMapMarkerCaptionStruct]";
}

struct RNCNaverMapMarkerSubCaptionStruct {
  std::string key;
  std::string text;
  int color;
  int haloColor;
  double textSize;
  double requestedWidth;
  double minZoom;
  double maxZoom;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapMarkerSubCaptionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_key = map.find("key");
  if (tmp_key != map.end()) {
    fromRawValue(context, tmp_key->second, result.key);
  }
  auto tmp_text = map.find("text");
  if (tmp_text != map.end()) {
    fromRawValue(context, tmp_text->second, result.text);
  }
  auto tmp_color = map.find("color");
  if (tmp_color != map.end()) {
    fromRawValue(context, tmp_color->second, result.color);
  }
  auto tmp_haloColor = map.find("haloColor");
  if (tmp_haloColor != map.end()) {
    fromRawValue(context, tmp_haloColor->second, result.haloColor);
  }
  auto tmp_textSize = map.find("textSize");
  if (tmp_textSize != map.end()) {
    fromRawValue(context, tmp_textSize->second, result.textSize);
  }
  auto tmp_requestedWidth = map.find("requestedWidth");
  if (tmp_requestedWidth != map.end()) {
    fromRawValue(context, tmp_requestedWidth->second, result.requestedWidth);
  }
  auto tmp_minZoom = map.find("minZoom");
  if (tmp_minZoom != map.end()) {
    fromRawValue(context, tmp_minZoom->second, result.minZoom);
  }
  auto tmp_maxZoom = map.find("maxZoom");
  if (tmp_maxZoom != map.end()) {
    fromRawValue(context, tmp_maxZoom->second, result.maxZoom);
  }
}

static inline std::string toString(const RNCNaverMapMarkerSubCaptionStruct &value) {
  return "[Object RNCNaverMapMarkerSubCaptionStruct]";
}
class RNCNaverMapMarkerProps final : public ViewProps {
 public:
  RNCNaverMapMarkerProps() = default;
  RNCNaverMapMarkerProps(const PropsParserContext& context, const RNCNaverMapMarkerProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  RNCNaverMapMarkerCoordStruct coord{};
  double width{0.0};
  double height{0.0};
  RNCNaverMapMarkerAnchorStruct anchor{};
  double angle{0.0};
  bool isFlatEnabled{false};
  bool isIconPerspectiveEnabled{false};
  double alpha{0.0};
  bool isHideCollidedSymbols{false};
  bool isHideCollidedMarkers{false};
  bool isHideCollidedCaptions{false};
  bool isForceShowIcon{false};
  int tintColor{0};
  RNCNaverMapMarkerImageStruct image{};
  RNCNaverMapMarkerCaptionStruct caption{};
  RNCNaverMapMarkerSubCaptionStruct subCaption{};
};

struct RNCNaverMapPathCoordsStruct {
  double latitude;
  double longitude;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPathCoordsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapPathCoordsStruct &value) {
  return "[Object RNCNaverMapPathCoordsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapPathCoordsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapPathCoordsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}

class RNCNaverMapPathProps final : public ViewProps {
 public:
  RNCNaverMapPathProps() = default;
  RNCNaverMapPathProps(const PropsParserContext& context, const RNCNaverMapPathProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  std::vector<RNCNaverMapPathCoordsStruct> coords{};
  double width{0.0};
  double outlineWidth{0.0};
  int patternInterval{0};
  double progress{0.0};
  int color{0};
  int passedColor{0};
  int outlineColor{0};
  int passedOutlineColor{0};
  bool isHideCollidedSymbols{false};
  bool isHideCollidedMarkers{false};
  bool isHideCollidedCaptions{false};
};

struct RNCNaverMapPolygonGeometriesCoordsStruct {
  double latitude;
  double longitude;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolygonGeometriesCoordsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapPolygonGeometriesCoordsStruct &value) {
  return "[Object RNCNaverMapPolygonGeometriesCoordsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapPolygonGeometriesCoordsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapPolygonGeometriesCoordsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNCNaverMapPolygonGeometriesHolesStruct {
  double latitude;
  double longitude;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolygonGeometriesHolesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapPolygonGeometriesHolesStruct &value) {
  return "[Object RNCNaverMapPolygonGeometriesHolesStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<std::vector<RNCNaverMapPolygonGeometriesHolesStruct>> &result) {
  auto items = (std::vector<std::vector<RawValue>>)value;
  for (const std::vector<RawValue> &item : items) {
    auto nestedArray = std::vector<RNCNaverMapPolygonGeometriesHolesStruct>{};
    for (const RawValue &nestedItem : item) {
      RNCNaverMapPolygonGeometriesHolesStruct newItem;
      fromRawValue(context, nestedItem, newItem);
      nestedArray.emplace_back(newItem);
    }
    result.emplace_back(nestedArray);
  }
}


struct RNCNaverMapPolygonGeometriesStruct {
  std::vector<RNCNaverMapPolygonGeometriesCoordsStruct> coords;
  std::vector<std::vector<RNCNaverMapPolygonGeometriesHolesStruct>> holes;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolygonGeometriesStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_coords = map.find("coords");
  if (tmp_coords != map.end()) {
    fromRawValue(context, tmp_coords->second, result.coords);
  }
  auto tmp_holes = map.find("holes");
  if (tmp_holes != map.end()) {
    fromRawValue(context, tmp_holes->second, result.holes);
  }
}

static inline std::string toString(const RNCNaverMapPolygonGeometriesStruct &value) {
  return "[Object RNCNaverMapPolygonGeometriesStruct]";
}
class RNCNaverMapPolygonProps final : public ViewProps {
 public:
  RNCNaverMapPolygonProps() = default;
  RNCNaverMapPolygonProps(const PropsParserContext& context, const RNCNaverMapPolygonProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  RNCNaverMapPolygonGeometriesStruct geometries{};
  int color{0};
  int outlineColor{0};
  double outlineWidth{0.0};
};

enum class RNCNaverMapPolylineCapType { Round, Butt, Square };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolylineCapType &result) {
  auto string = (std::string)value;
  if (string == "Round") { result = RNCNaverMapPolylineCapType::Round; return; }
  if (string == "Butt") { result = RNCNaverMapPolylineCapType::Butt; return; }
  if (string == "Square") { result = RNCNaverMapPolylineCapType::Square; return; }
  abort();
}

static inline std::string toString(const RNCNaverMapPolylineCapType &value) {
  switch (value) {
    case RNCNaverMapPolylineCapType::Round: return "Round";
    case RNCNaverMapPolylineCapType::Butt: return "Butt";
    case RNCNaverMapPolylineCapType::Square: return "Square";
  }
}
enum class RNCNaverMapPolylineJoinType { Bevel, Miter, Round };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolylineJoinType &result) {
  auto string = (std::string)value;
  if (string == "Bevel") { result = RNCNaverMapPolylineJoinType::Bevel; return; }
  if (string == "Miter") { result = RNCNaverMapPolylineJoinType::Miter; return; }
  if (string == "Round") { result = RNCNaverMapPolylineJoinType::Round; return; }
  abort();
}

static inline std::string toString(const RNCNaverMapPolylineJoinType &value) {
  switch (value) {
    case RNCNaverMapPolylineJoinType::Bevel: return "Bevel";
    case RNCNaverMapPolylineJoinType::Miter: return "Miter";
    case RNCNaverMapPolylineJoinType::Round: return "Round";
  }
}
struct RNCNaverMapPolylineCoordsStruct {
  double latitude;
  double longitude;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapPolylineCoordsStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
}

static inline std::string toString(const RNCNaverMapPolylineCoordsStruct &value) {
  return "[Object RNCNaverMapPolylineCoordsStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapPolylineCoordsStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapPolylineCoordsStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}

class RNCNaverMapPolylineProps final : public ViewProps {
 public:
  RNCNaverMapPolylineProps() = default;
  RNCNaverMapPolylineProps(const PropsParserContext& context, const RNCNaverMapPolylineProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  int zIndexValue{0};
  bool isHidden{false};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isMinZoomInclusive{false};
  bool isMaxZoomInclusive{false};
  std::vector<RNCNaverMapPolylineCoordsStruct> coords{};
  double width{0.0};
  int color{0};
  std::vector<int> pattern{};
  RNCNaverMapPolylineCapType capType{RNCNaverMapPolylineCapType::Round};
  RNCNaverMapPolylineJoinType joinType{RNCNaverMapPolylineJoinType::Round};
};

enum class RNCNaverMapViewMapType { Basic, Navi, Satellite, Hybrid, Terrain, NaviHybrid, None };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewMapType &result) {
  auto string = (std::string)value;
  if (string == "Basic") { result = RNCNaverMapViewMapType::Basic; return; }
  if (string == "Navi") { result = RNCNaverMapViewMapType::Navi; return; }
  if (string == "Satellite") { result = RNCNaverMapViewMapType::Satellite; return; }
  if (string == "Hybrid") { result = RNCNaverMapViewMapType::Hybrid; return; }
  if (string == "Terrain") { result = RNCNaverMapViewMapType::Terrain; return; }
  if (string == "NaviHybrid") { result = RNCNaverMapViewMapType::NaviHybrid; return; }
  if (string == "None") { result = RNCNaverMapViewMapType::None; return; }
  abort();
}

static inline std::string toString(const RNCNaverMapViewMapType &value) {
  switch (value) {
    case RNCNaverMapViewMapType::Basic: return "Basic";
    case RNCNaverMapViewMapType::Navi: return "Navi";
    case RNCNaverMapViewMapType::Satellite: return "Satellite";
    case RNCNaverMapViewMapType::Hybrid: return "Hybrid";
    case RNCNaverMapViewMapType::Terrain: return "Terrain";
    case RNCNaverMapViewMapType::NaviHybrid: return "NaviHybrid";
    case RNCNaverMapViewMapType::None: return "None";
  }
}
enum class RNCNaverMapViewLogoAlign { TopLeft, TopRight, BottomLeft, BottomRight };

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLogoAlign &result) {
  auto string = (std::string)value;
  if (string == "TopLeft") { result = RNCNaverMapViewLogoAlign::TopLeft; return; }
  if (string == "TopRight") { result = RNCNaverMapViewLogoAlign::TopRight; return; }
  if (string == "BottomLeft") { result = RNCNaverMapViewLogoAlign::BottomLeft; return; }
  if (string == "BottomRight") { result = RNCNaverMapViewLogoAlign::BottomRight; return; }
  abort();
}

static inline std::string toString(const RNCNaverMapViewLogoAlign &value) {
  switch (value) {
    case RNCNaverMapViewLogoAlign::TopLeft: return "TopLeft";
    case RNCNaverMapViewLogoAlign::TopRight: return "TopRight";
    case RNCNaverMapViewLogoAlign::BottomLeft: return "BottomLeft";
    case RNCNaverMapViewLogoAlign::BottomRight: return "BottomRight";
  }
}
struct RNCNaverMapViewInitialCameraStruct {
  double latitude;
  double longitude;
  double zoom;
  double tilt;
  double bearing;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewInitialCameraStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_zoom = map.find("zoom");
  if (tmp_zoom != map.end()) {
    fromRawValue(context, tmp_zoom->second, result.zoom);
  }
  auto tmp_tilt = map.find("tilt");
  if (tmp_tilt != map.end()) {
    fromRawValue(context, tmp_tilt->second, result.tilt);
  }
  auto tmp_bearing = map.find("bearing");
  if (tmp_bearing != map.end()) {
    fromRawValue(context, tmp_bearing->second, result.bearing);
  }
}

static inline std::string toString(const RNCNaverMapViewInitialCameraStruct &value) {
  return "[Object RNCNaverMapViewInitialCameraStruct]";
}

struct RNCNaverMapViewCameraStruct {
  double latitude;
  double longitude;
  double zoom;
  double tilt;
  double bearing;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewCameraStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_zoom = map.find("zoom");
  if (tmp_zoom != map.end()) {
    fromRawValue(context, tmp_zoom->second, result.zoom);
  }
  auto tmp_tilt = map.find("tilt");
  if (tmp_tilt != map.end()) {
    fromRawValue(context, tmp_tilt->second, result.tilt);
  }
  auto tmp_bearing = map.find("bearing");
  if (tmp_bearing != map.end()) {
    fromRawValue(context, tmp_bearing->second, result.bearing);
  }
}

static inline std::string toString(const RNCNaverMapViewCameraStruct &value) {
  return "[Object RNCNaverMapViewCameraStruct]";
}

struct RNCNaverMapViewInitialRegionStruct {
  double latitude;
  double longitude;
  double latitudeDelta;
  double longitudeDelta;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewInitialRegionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_latitudeDelta = map.find("latitudeDelta");
  if (tmp_latitudeDelta != map.end()) {
    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
  }
  auto tmp_longitudeDelta = map.find("longitudeDelta");
  if (tmp_longitudeDelta != map.end()) {
    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
  }
}

static inline std::string toString(const RNCNaverMapViewInitialRegionStruct &value) {
  return "[Object RNCNaverMapViewInitialRegionStruct]";
}

struct RNCNaverMapViewRegionStruct {
  double latitude;
  double longitude;
  double latitudeDelta;
  double longitudeDelta;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewRegionStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_latitudeDelta = map.find("latitudeDelta");
  if (tmp_latitudeDelta != map.end()) {
    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
  }
  auto tmp_longitudeDelta = map.find("longitudeDelta");
  if (tmp_longitudeDelta != map.end()) {
    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
  }
}

static inline std::string toString(const RNCNaverMapViewRegionStruct &value) {
  return "[Object RNCNaverMapViewRegionStruct]";
}

struct RNCNaverMapViewMapPaddingStruct {
  double top;
  double right;
  double bottom;
  double left;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewMapPaddingStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_right = map.find("right");
  if (tmp_right != map.end()) {
    fromRawValue(context, tmp_right->second, result.right);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
  auto tmp_left = map.find("left");
  if (tmp_left != map.end()) {
    fromRawValue(context, tmp_left->second, result.left);
  }
}

static inline std::string toString(const RNCNaverMapViewMapPaddingStruct &value) {
  return "[Object RNCNaverMapViewMapPaddingStruct]";
}

struct RNCNaverMapViewLogoMarginStruct {
  double top;
  double right;
  double bottom;
  double left;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewLogoMarginStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_top = map.find("top");
  if (tmp_top != map.end()) {
    fromRawValue(context, tmp_top->second, result.top);
  }
  auto tmp_right = map.find("right");
  if (tmp_right != map.end()) {
    fromRawValue(context, tmp_right->second, result.right);
  }
  auto tmp_bottom = map.find("bottom");
  if (tmp_bottom != map.end()) {
    fromRawValue(context, tmp_bottom->second, result.bottom);
  }
  auto tmp_left = map.find("left");
  if (tmp_left != map.end()) {
    fromRawValue(context, tmp_left->second, result.left);
  }
}

static inline std::string toString(const RNCNaverMapViewLogoMarginStruct &value) {
  return "[Object RNCNaverMapViewLogoMarginStruct]";
}

struct RNCNaverMapViewExtentStruct {
  double latitude;
  double longitude;
  double latitudeDelta;
  double longitudeDelta;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewExtentStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_latitudeDelta = map.find("latitudeDelta");
  if (tmp_latitudeDelta != map.end()) {
    fromRawValue(context, tmp_latitudeDelta->second, result.latitudeDelta);
  }
  auto tmp_longitudeDelta = map.find("longitudeDelta");
  if (tmp_longitudeDelta != map.end()) {
    fromRawValue(context, tmp_longitudeDelta->second, result.longitudeDelta);
  }
}

static inline std::string toString(const RNCNaverMapViewExtentStruct &value) {
  return "[Object RNCNaverMapViewExtentStruct]";
}

struct RNCNaverMapViewClustersClustersMarkersImageStruct {
  std::string symbol;
  std::string rnAssetUri;
  std::string httpUri;
  std::string assetName;
  std::string reuseIdentifier;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewClustersClustersMarkersImageStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_symbol = map.find("symbol");
  if (tmp_symbol != map.end()) {
    fromRawValue(context, tmp_symbol->second, result.symbol);
  }
  auto tmp_rnAssetUri = map.find("rnAssetUri");
  if (tmp_rnAssetUri != map.end()) {
    fromRawValue(context, tmp_rnAssetUri->second, result.rnAssetUri);
  }
  auto tmp_httpUri = map.find("httpUri");
  if (tmp_httpUri != map.end()) {
    fromRawValue(context, tmp_httpUri->second, result.httpUri);
  }
  auto tmp_assetName = map.find("assetName");
  if (tmp_assetName != map.end()) {
    fromRawValue(context, tmp_assetName->second, result.assetName);
  }
  auto tmp_reuseIdentifier = map.find("reuseIdentifier");
  if (tmp_reuseIdentifier != map.end()) {
    fromRawValue(context, tmp_reuseIdentifier->second, result.reuseIdentifier);
  }
}

static inline std::string toString(const RNCNaverMapViewClustersClustersMarkersImageStruct &value) {
  return "[Object RNCNaverMapViewClustersClustersMarkersImageStruct]";
}

struct RNCNaverMapViewClustersClustersMarkersStruct {
  double latitude;
  double longitude;
  std::string identifier;
  RNCNaverMapViewClustersClustersMarkersImageStruct image;
  double width;
  double height;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewClustersClustersMarkersStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_latitude = map.find("latitude");
  if (tmp_latitude != map.end()) {
    fromRawValue(context, tmp_latitude->second, result.latitude);
  }
  auto tmp_longitude = map.find("longitude");
  if (tmp_longitude != map.end()) {
    fromRawValue(context, tmp_longitude->second, result.longitude);
  }
  auto tmp_identifier = map.find("identifier");
  if (tmp_identifier != map.end()) {
    fromRawValue(context, tmp_identifier->second, result.identifier);
  }
  auto tmp_image = map.find("image");
  if (tmp_image != map.end()) {
    fromRawValue(context, tmp_image->second, result.image);
  }
  auto tmp_width = map.find("width");
  if (tmp_width != map.end()) {
    fromRawValue(context, tmp_width->second, result.width);
  }
  auto tmp_height = map.find("height");
  if (tmp_height != map.end()) {
    fromRawValue(context, tmp_height->second, result.height);
  }
}

static inline std::string toString(const RNCNaverMapViewClustersClustersMarkersStruct &value) {
  return "[Object RNCNaverMapViewClustersClustersMarkersStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapViewClustersClustersMarkersStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapViewClustersClustersMarkersStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNCNaverMapViewClustersClustersStruct {
  std::string key;
  std::vector<RNCNaverMapViewClustersClustersMarkersStruct> markers;
  double screenDistance;
  double minZoom;
  double maxZoom;
  bool animate;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewClustersClustersStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_key = map.find("key");
  if (tmp_key != map.end()) {
    fromRawValue(context, tmp_key->second, result.key);
  }
  auto tmp_markers = map.find("markers");
  if (tmp_markers != map.end()) {
    fromRawValue(context, tmp_markers->second, result.markers);
  }
  auto tmp_screenDistance = map.find("screenDistance");
  if (tmp_screenDistance != map.end()) {
    fromRawValue(context, tmp_screenDistance->second, result.screenDistance);
  }
  auto tmp_minZoom = map.find("minZoom");
  if (tmp_minZoom != map.end()) {
    fromRawValue(context, tmp_minZoom->second, result.minZoom);
  }
  auto tmp_maxZoom = map.find("maxZoom");
  if (tmp_maxZoom != map.end()) {
    fromRawValue(context, tmp_maxZoom->second, result.maxZoom);
  }
  auto tmp_animate = map.find("animate");
  if (tmp_animate != map.end()) {
    fromRawValue(context, tmp_animate->second, result.animate);
  }
}

static inline std::string toString(const RNCNaverMapViewClustersClustersStruct &value) {
  return "[Object RNCNaverMapViewClustersClustersStruct]";
}

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, std::vector<RNCNaverMapViewClustersClustersStruct> &result) {
  auto items = (std::vector<RawValue>)value;
  for (const auto &item : items) {
    RNCNaverMapViewClustersClustersStruct newItem;
    fromRawValue(context, item, newItem);
    result.emplace_back(newItem);
  }
}


struct RNCNaverMapViewClustersStruct {
  std::string key;
  std::vector<RNCNaverMapViewClustersClustersStruct> clusters;
};

static inline void fromRawValue(const PropsParserContext& context, const RawValue &value, RNCNaverMapViewClustersStruct &result) {
  auto map = (std::unordered_map<std::string, RawValue>)value;

  auto tmp_key = map.find("key");
  if (tmp_key != map.end()) {
    fromRawValue(context, tmp_key->second, result.key);
  }
  auto tmp_clusters = map.find("clusters");
  if (tmp_clusters != map.end()) {
    fromRawValue(context, tmp_clusters->second, result.clusters);
  }
}

static inline std::string toString(const RNCNaverMapViewClustersStruct &value) {
  return "[Object RNCNaverMapViewClustersStruct]";
}
class RNCNaverMapViewProps final : public ViewProps {
 public:
  RNCNaverMapViewProps() = default;
  RNCNaverMapViewProps(const PropsParserContext& context, const RNCNaverMapViewProps &sourceProps, const RawProps &rawProps);

#pragma mark - Props

  RNCNaverMapViewMapType mapType{RNCNaverMapViewMapType::Basic};
  int layerGroups{0};
  RNCNaverMapViewInitialCameraStruct initialCamera{};
  RNCNaverMapViewCameraStruct camera{};
  RNCNaverMapViewInitialRegionStruct initialRegion{};
  RNCNaverMapViewRegionStruct region{};
  int animationDuration{0};
  int animationEasing{0};
  bool isIndoorEnabled{false};
  bool isNightModeEnabled{false};
  bool isLiteModeEnabled{false};
  double lightness{0.0};
  double buildingHeight{0.0};
  double symbolScale{0.0};
  double symbolPerspectiveRatio{0.0};
  RNCNaverMapViewMapPaddingStruct mapPadding{};
  double minZoom{0.0};
  double maxZoom{0.0};
  bool isShowCompass{false};
  bool isShowScaleBar{false};
  bool isShowZoomControls{false};
  bool isShowIndoorLevelPicker{false};
  bool isShowLocationButton{false};
  RNCNaverMapViewLogoAlign logoAlign{RNCNaverMapViewLogoAlign::BottomLeft};
  RNCNaverMapViewLogoMarginStruct logoMargin{};
  RNCNaverMapViewExtentStruct extent{};
  bool isScrollGesturesEnabled{false};
  bool isZoomGesturesEnabled{false};
  bool isTiltGesturesEnabled{false};
  bool isRotateGesturesEnabled{false};
  bool isUseTextureViewAndroid{false};
  bool isStopGesturesEnabled{false};
  std::string locale{};
  RNCNaverMapViewClustersStruct clusters{};
};

} // namespace facebook::react
